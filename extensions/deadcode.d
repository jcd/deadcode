module extensions.deadcode;
import std.algorithm;
import std.array;
import std.file;
import std.path;
import std.process;

import extensionapi;

mixin registerCommandsRPC;

string[] extensionBuildsInProgress;
string[] scheduleExtensionBuild;

void deadcodeBuildAndStartExtension(Application app, string path)
{
	 //string path = "fdsa";
	// Check if a build of this extension is already running and in that case just reschedule build and return.
	import std.stdio;
       writeln("build and restart called");
	if (extensionBuildsInProgress.canFind(path))
    {
	    if (!scheduleExtensionBuild.canFind(path))
	       scheduleExtensionBuild ~= path;
		return;
    }
       writeln("build and restart called2 ", path);

	// Setup build work dir and build dub file
	auto relExtPath = path.pathSplitter.find("extensions").array.join();
    if (relExtPath.empty)
    {
	    import std.stdio;
		writeln("Cannot build extension that is not in a 'extensions' folder");
        return;

    }

	// Dub create dub file for extension
	string extWorkDirAbs = createExtensionWorkspace(app.getExecutableDir(), app.getUserDataDir(), relExtPath, path);
	import extensions.dub.build;

    // Build extension
	auto builder = new Builder(extWorkDirAbs, "debug", "plugin.exe");
	builder.onBuildMessage.connectTo((string  msg, LogLevel l) {
        writeln(msg);
    });
    builder.onBuildFinished.connectTo((BuildStatus s) {
       writeln("done building to ", s.target, " ", s.exitCode);

        if (scheduleExtensionBuild.canFind(path))
            app.scheduleCommand("deadcode.buildAndStartExtension", path);
        else if (s.exitCode == 0)
            app.startExtension(s.target);
    });

       writeln("build and restart running");
    builder.run();
       writeln("build and restart running called");

    //import core.thread;
    //import core.time;
    //while (builder.checkBuildStatus())
    //    Thread.sleep(dur!"msecs"(200));

    // Test run
	// Check if extensions is already running and if so kill it.
    // Move extension executable to final destinstation
	// Spawn extension
    // Check that it spawned and registered stuff as expected or revert to old executable
	// Check if the extension has been scheduled for rebuild and rebuild if so.
}


private string createExtensionWorkspace(string sourceDir, string userDataDir, string relativeExtensionPath, string path)
{
	enum dubTemplate = q"{
{
	"name": "%s",
	"description": "DeadCode - %s Client",
	"homepage": "http://deadcode.steamwinter.com",
	"copyright": "Autogenerated",
	"mainSourceFile" : "%s",
	"authors": [
		"Deadcode extension"
	],
	"dependencies": {
		"msgpack-d": "~>0.9.5"
	},
	"versions-windows": ["Unicode", "DeadcodeClient" ],
	"lflags-windows": ["/NOCODEVIEW"],
	"sourcePaths": [ "%s", "%s" ],
	"buildRequirements": ["allowWarnings"],
	"importPaths": [
    ],
    "targetType": "executable",
	"dflags" : ["-vcolumns"],
    "targetName" : "%s",
	"buildTypes" : {
        "debug" : {
        	"buildOptions" : [ "debugMode", "debugInfo" ]
        }
    }
}

    }";

	struct ExtInfo
    {
		string name;
        string descriptionName;
        string mainSourceFile;
        string clientLibSourcesDir;
        string baseLibSourcesDir;
        string target;
    }
//    "sourceFiles": [ "%s" ],

	string extWorkDirAbs = buildPath(userDataDir, "extensions", relativeExtensionPath.replace(".d", "")["extensions".length..$]);
    import std.file;
    mkdirRecurse(extWorkDirAbs);

    auto info = ExtInfo();
    info.name = relativeExtensionPath.replace("/", "_").replace("\\", "_").replace(".d", "");
	info.descriptionName = info.name;
    info.mainSourceFile = path.replace("\\","/");
    info.clientLibSourcesDir = buildPath(sourceDir, "deadcodeclient").replace("\\","/");
    info.baseLibSourcesDir = buildPath(sourceDir, "deadcodebase").replace("\\","/");
   // info.baseLibSourcesDir = buildPath(sourceDir, "deadcodebase").replace("\\","/");

version (Windows)
    info.target = "extension";
else
    info.target = "extension.exe";

	string dubFilePath = buildPath(extWorkDirAbs, "dub.json");

	import std.format;
    write(dubFilePath, format(dubTemplate, info.name, info.descriptionName, info.mainSourceFile,
						      info.clientLibSourcesDir, info.baseLibSourcesDir,
                              info.target));
	return extWorkDirAbs;
}

void restartExtensions(Application app)
{
	auto dir = buildPath(app.getUserDataDir(), "extensions");
    foreach (e; dirEntries(dir, "*.exe", SpanMode.depth))
    {
        if (!e.name.canFind(".dub"))
	        spawnExtension(e);
    }
}

private void spawnExtension(DirEntry e)
{
	import std.stdio;
	writeln("Starting extension ", e.name);
	auto pid = spawnProcess(e.name, stdin, stdout, stderr, null, Config.suppressConsole);
}

private void removeInProgress(string path)
{
    extensionBuildsInProgress = extensionBuildsInProgress.remove!(a => a == path, SwapStrategy.unstable);
    assumeSafeAppend(extensionBuildsInProgress);
}
